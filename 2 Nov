Hereâ€™s a **complete breakdown** of your solution â€” including **approach**, **code with comments**, **time complexity**, and **space complexity** ðŸ‘‡

---

### ðŸ§  **Approach (Optimized)**

1. Represent the grid with:

   * `0` â†’ empty cell
   * `1` â†’ guard
   * `2` â†’ wall
2. Use another grid `vis` to mark **cells visible to guards**.
3. For each row and column, simulate **guard vision** in **four directions**:

   * **Left â†’ Right**
   * **Right â†’ Left**
   * **Top â†’ Bottom**
   * **Bottom â†’ Top**
4. When a guard is seen, set `watch = true` and mark all empty cells as visible until a wall blocks (`watch = false` when wall found).
5. Finally, count cells where:

   * Itâ€™s empty (`grid[i][j] == 0`)
   * Not watched (`vis[i][j] == 0`)

---

### ðŸ’» **Code (with full comments)**

```cpp
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        // grid[i][j]: 0 = empty, 1 = guard, 2 = wall
        vector<vector<int>> grid(m, vector<int>(n, 0));
        // vis[i][j]: 1 = cell watched by a guard
        vector<vector<int>> vis(m, vector<int>(n, 0));

        // Mark guards
        for (auto &g : guards) grid[g[0]][g[1]] = 1;
        // Mark walls
        for (auto &w : walls) grid[w[0]][w[1]] = 2;

        // LEFT â†’ RIGHT vision
        for (int i = 0; i < m; i++) {
            bool watch = false;
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) watch = true;       // guard starts watching
                else if (grid[i][j] == 2) watch = false; // wall blocks view
                else if (watch) vis[i][j] = 1;           // mark cell as visible
            }
        }

        // RIGHT â†’ LEFT vision
        for (int i = 0; i < m; i++) {
            bool watch = false;
            for (int j = n - 1; j >= 0; j--) {
                if (grid[i][j] == 1) watch = true;
                else if (grid[i][j] == 2) watch = false;
                else if (watch) vis[i][j] = 1;
            }
        }

        // TOP â†’ BOTTOM vision
        for (int j = 0; j < n; j++) {
            bool watch = false;
            for (int i = 0; i < m; i++) {
                if (grid[i][j] == 1) watch = true;
                else if (grid[i][j] == 2) watch = false;
                else if (watch) vis[i][j] = 1;
            }
        }

        // BOTTOM â†’ TOP vision
        for (int j = 0; j < n; j++) {
            bool watch = false;
            for (int i = m - 1; i >= 0; i--) {
                if (grid[i][j] == 1) watch = true;
                else if (grid[i][j] == 2) watch = false;
                else if (watch) vis[i][j] = 1;
            }
        }

        // Count unguarded (unwatched empty) cells
        int cnt = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0 && vis[i][j] == 0)
                    cnt++;
            }
        }

        return cnt;
    }
};
```

---

### â± **Time Complexity**

* Four passes through the grid â†’ **O(4 Ã— m Ã— n) = O(m Ã— n)**
  âœ… Efficient and linear in grid size.

### ðŸ’¾ **Space Complexity**

* Two 2D arrays (`grid` and `vis`) of size `m Ã— n` â†’ **O(m Ã— n)**

---

### âœ… **Summary**

| Aspect               | Description                                              |
| -------------------- | -------------------------------------------------------- |
| **Approach**         | Simulate guard visibility in four directions, skip walls |
| **Time Complexity**  | O(m Ã— n)                                                 |
| **Space Complexity** | O(m Ã— n)                                                 |
| **Category**         | Optimized linear sweep (better than BFS/Brute)           |

---

Would you like me to also show the **brute-force and intermediate optimized (BFS) versions** for comparison with this best approa
