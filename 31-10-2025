Link:-https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/?envType=daily-question&envId=2025-10-31

ğŸ”¹ 1. Brute Force
ğŸ’¡ Logic:

Compare every pair. If two numbers are same â†’ mark as duplicate.

ğŸ’» Code:
vector<int> getSneakyNumbers(vector<int>& nums) {
    vector<int> ans;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[i] == nums[j]) ans.push_back(nums[i]);
        }
    }
    return ans;
}

â±ï¸ Time: O(nÂ²)
ğŸ’¾ Space: O(1)
ğŸ”¹ 2. Optimized (Using Frequency Array / Hashing)
ğŸ’¡ Logic:

Use an array freq[n] to count occurrences.
If freq[num] == 1, that number is duplicate.

ğŸ’» Code:
vector<int> getSneakyNumbers(vector<int>& nums) {
    int n = nums.size();
    vector<int> freq(n, 0), ans;

    for (int num : nums) {
        if (freq[num] == 1) ans.push_back(num);
        else freq[num]++;
    }
    return ans;
}

â±ï¸ Time: O(n)
ğŸ’¾ Space: O(n)
ğŸ”¹ 3. Best (In-Place Marking)
ğŸ’¡ Logic:

Use the array itself as a visited marker.
For each num, check nums[abs(num)]:

If already negative â†’ duplicate.

Else â†’ make it negative.

âš ï¸ Fails for 0 unless handled separately.

ğŸ’» Code:
vector<int> getSneakyNumbers(vector<int>& nums) {
    vector<int> ans;
    for (int i = 0; i < nums.size(); i++) {
        int index = abs(nums[i]);
        if (nums[index] < 0) ans.push_back(index);
        else nums[index] = -nums[index];
    }
    return ans;
}

â±ï¸ Time: O(n)
ğŸ’¾ Space: O(1)

âœ… Interview Summary Table

Approach	Idea	Time	Space
Brute	Compare every pair	O(nÂ²)	O(1)
Optimized	Frequency array	O(n)	O(n)
Best	In-place marking using signs	O(n)	O(1)
